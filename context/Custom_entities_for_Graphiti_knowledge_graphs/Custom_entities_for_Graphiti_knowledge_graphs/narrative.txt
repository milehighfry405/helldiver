The decision to use custom entities in Graphiti for your structured research pipeline hinges on a fundamental tension: preserving the provenance and analytical lens of your multi-agent system while leveraging Graphiti's design philosophy of schema consistency and simplicity. Your closed system—where three research agents generate primary insights, a critical analyst identifies gaps, and user context transforms information into actionable knowledge—creates a unique opportunity that Graphiti's architecture can exploit, but only if you understand how entity extraction actually works.

When Graphiti processes your episodes, it passes content to OpenAI for entity extraction without inherently knowing which agent produced what insight—the LLM sees text, not metadata about whether it came from your devil's advocate or primary researcher. This blindness to source context means default entities would flatten the distinction between "validated market fact" and "critical counterargument," losing the signal that makes your knowledge graph execution-grade. Custom entities solve this by embedding provenance directly into the schema: a ResearchFinding entity with a source_agent attribute preserves not just what was discovered but who discovered it and why it matters, while a CriticalAnalysis entity captures gaps and counterarguments as first-class citizens rather than generic observations.

The research reveals that Graphiti maintains bidirectional indices between episodes and their derived entities through MENTIONS edges, enabling provenance queries even without custom entities—but this episode-level tracking requires complex traversal compared to direct entity-type queries. Your execution agents asking "What did the critical analyst challenge?" would need to filter through episode metadata rather than querying CriticalAnalysis entities directly, adding latency and complexity to what should be simple operations. The hybrid approach emerges as optimal: use strategic custom entities for research artifacts while leveraging episode metadata for additional context, creating queryable provenance without over-engineering the schema.

The critical analyst's assessment exposes the core uncertainty: while custom entities clearly preserve more signal for your use case, the research cannot guarantee that custom Pydantic attributes will persist to Neo4j as expected—users report inconsistent behavior with custom properties. This implementation risk, combined with Graphiti's LLM-based extraction lacking completeness guarantees, suggests starting with defaults plus rich episode metadata, then upgrading to custom entities only after validating that default extraction misses critical distinctions your execution agents need. The confidence remains high that custom entities would improve signal preservation, but the implementation path should be iterative rather than assumptive, documenting each decision in the graph itself to build institutional knowledge about what works.